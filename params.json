{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Luvi","tagline":"Luvi: A distributed parallel video transcoder","body":"Luvi: A distributed parallel video transcoder\r\n=============================================\r\n\r\nThis program opens your input movie, streams the frames out to \r\nmultiple computers (slaves), transcodes them in parallel, \r\nreturns the transcoded frames back to the master computer and \r\nsaves the resulting video to a new file.\r\n\r\nOriginally, the intent of this program was to take my MythTV \r\nrecordings and use the computers in my house in parallel to convert \r\nthem them to a high-quality Bluray-compatible format in a much \r\nfaster time than a single computer could do.\r\n\r\nDEPENDENCIES:\r\n=============================================\r\n\r\nA) ffmpeg 1.0 and higher: Compile or install them however you see fit\r\nB) x264: The only codec supported right now for transcoding. With additional help, this can easily be improved.\r\nC) Protocol Buffers: google's data exchange format for network communication\r\nD) libxdo2: A nice library used to keep the computers from going to sleep while they video is being farmed out for transcoding.\r\n\r\n\r\nUSAGE:\r\n=============================================\r\nUsage is fairly manual right now.... a GUI would be a logical next step.\r\n\r\n1. Run the master like this:\r\n\r\n    $ ./master [ input video filename ] [ output.m2ts ] [ port # to which slaves should connect ] [ 0 | 1 ]\r\n    \r\n  # The last parameter:\r\n\t\t\t'1' means: transcode in parallel using slaves\r\n\t\t\t'0' means: transcode locally (for debugging purposes)\r\n\tExample:\r\n\t   \r\n     $ ./master input.mpg output.m2ts 1264 1 # start and wait for slaves\r\n\r\n   At this point, the master will print:\r\n    Ready for slaves.\r\n    Waiting for slaves...\r\n    Waiting for slaves...\r\n    Waiting for slaves...\r\n\r\n2. Then, on as many computers as you have, run the slaves, like this:\r\n\r\n    $ ./slave [ address/name of master ] [ port # ]\r\n\r\n\tExample:\r\n\t  \r\n    $ ./slave localhost 1264 # connect to master and start working\r\n\r\n3. If you just want to make sure the encoding *works* first locally\r\n   without any parallelism (for example to make sure you have the right\r\n   ffmpeg libraries installed):\r\n\r\n\tExample:\r\n  \r\n    $ ./master input.mpg output.m2ts 1264 0  # will transcode immediately without slaves\r\n\r\nCONFIGURING:\r\n=============================================\r\n\r\nThings like x264 bitrates, profiles, presets, GOP sizes, and so forth\r\nare all hard-coded inside \"common.c\".\r\n\r\nEventually a configuration system will get written when I have free time.\r\n\r\nFeel free to modify (common.c) the file until that time comes....\r\n\r\nPatches welcome =)\r\n\r\nHOW IT WORKS:\r\n======================================\r\n\r\nParallelism works by grouping multiple GOPs together (currently almost 1000 frames,\r\nspanning about 45-60 frames/GOP on average from the videos I've tested with) \r\ninto \"ranges\" of GOPs.\r\n\r\nEach \"range\" of GOPs is assigned to a slave. The range includes a \"scene-change\" GOP from\r\nthe previous range which ensures that encoding is done cleanly between the slaves. This\r\nis done by retaining the last GOP of a range and sending it along to the next slave when\r\nthe next slave is chosen.\r\n\r\nEverything happens in a single pass: All the video is transcoded in the same order\r\nthat it was read from the original video and written back out to the new video in that same\r\norder. This is done by ordering the transcoded ranges into a FIFO while they are multiplexed\r\nacross all the slaves.\r\n\r\nThe audio is just copied, right now. It is not transcoded.\r\n\r\nThe resulting video is written to an MPEG Transport Stream container.\r\n\r\nBUGS:\r\n======================================\r\nNo bugs with the video transcoding or synchronization.\r\n\r\nThe audio copying is weird: It plays back fine in VLC / Mplayer on my desktop,\r\nbut unless I to do the following to get the audio stream to function\r\nproperly on a Bluray Disk (tsMuxeR won't accept it):\r\n\r\nBy doing the following:\r\n\r\n    $ ffmpeg -i output.m2ts -vcodec copy -acodec copy -f mpegts -copyts result.m2ts\r\n\r\nThis some how \"sanitizes\" the copied audio stream in a way that I don't \r\nunderstand, but makes the audio stream compatible for Bluray. Perhaps someone \r\ncould help me track down the problem in my code when I copy the audio packets.\r\n\r\nPATCHES / Reporting Bugs:\r\n======================================\r\nIf you find a bug *cough* segfault *cough*,\r\nplease for god's sake, run GDB first.\r\n\r\nPatches welcome!\r\n","google":""}